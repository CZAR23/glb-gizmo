<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>LegoCAD-like Sandbox (Three.js)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #0e0f13; }
      #app { display: block; }

      #sidebar {
        position: fixed; top: 0; right: 0; bottom: 0; width: 220px;
        background: #181a20; border-left: 1px solid #2c2f3a; padding: 12px;
        color: #e7eaf2; font-family: system-ui; overflow-y: auto; z-index: 5;
      }
      #sidebar h3 { margin: 6px 0 10px; font-size: 16px; }
      .part-btn {
        display: block; width: 100%; margin: 6px 0; padding: 8px 10px;
        background: #2c2f3a; border: 0; border-radius: 8px; color: #fff;
        text-align: left; cursor: pointer;
      }
      .part-btn:hover { background: #3b4052; }
      #hint {
        position: fixed; left: 12px; bottom: 12px; padding: 8px 10px;
        background: #12151c; color: #c8cede; border: 1px solid #2b2f3a; border-radius: 10px;
        font-family: system-ui; font-size: 13px; z-index: 5;
      }
      #hint code { background: #0b0e14; padding: 1px 5px; border-radius: 6px; }
      
      #gizmo-container {
        position: absolute;
        top: 10px;
        right: 240px;
        width: 80px;
        height: 80px;
        border: 1px solid #333;
        border-radius: 4px;
        z-index: 10;
        pointer-events: auto;
      }

      #multi-controls {
        position: fixed;
        top: 10px;
        left: 10px;
        background: #181a20;
        border: 1px solid #2c2f3a;
        border-radius: 8px;
        padding: 10px;
        color: #e7eaf2;
        font-family: system-ui;
        font-size: 12px;
        z-index: 10;
      }
      
      #multi-controls h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
      }
      
      .control-btn {
        padding: 4px 8px;
        margin: 2px;
        background: #2c2f3a;
        border: none;
        border-radius: 4px;
        color: #fff;
        cursor: pointer;
        font-size: 11px;
      }
      
      .control-btn:hover {
        background: #3b4052;
      }

      .debug-controls {
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px solid #2c2f3a;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <canvas id="app"></canvas>
    <div id="gizmo-container"></div>

    <div id="multi-controls">
      <h4>Multi-Selection</h4>
      <div>Selected: <span id="selected-count">0</span></div>
      <button class="control-btn" id="clear-selection">Clear All</button>
      <button class="control-btn" id="delete-selected">Delete Selected</button>
      
      <div class="debug-controls">
        <h4>Debug</h4>
        <button class="control-btn" id="toggle-grid">Grid Removed</button>
        <button class="control-btn" id="toggle-debug">Show Collision Box</button>
        <button class="control-btn" id="disable-collision">Disable Collision</button>
      </div>
    </div>

    <div id="sidebar">
      <h3>Parts</h3>
      <button class="part-btn" data-model="Beam_2.glb">Beam_2</button>
      <button class="part-btn" data-model="Beam_3.glb">Beam_3</button>
      <button class="part-btn" data-model="Beam_5.glb">Beam_5</button>
      <button class="part-btn" data-model="Beam_7.glb">Beam_7</button>
      <button class="part-btn" data-model="Beam_9.glb">Beam_9</button>
      <button class="part-btn" data-model="Beam_11.glb">Beam_11</button>
      <button class="part-btn" data-model="Beam_13.glb">Beam_13</button>
      <button class="part-btn" data-model="Beam_15.glb">Beam_15</button>
      <button class="part-btn" data-model="Wheel_24mm.glb">Wheel_24mm</button>
      <button class="part-btn" data-model="Wheel_30mm.glb">Wheel_30mm</button>
      <button class="part-btn" data-model="4x4_Angled_Beam.glb">4x4_Angled_Beam</button>
      <button class="part-btn" data-model="2x4_L_Shaped_Beam.glb">2x4_L_Shaped_Beam</button>
      <button class="part-btn" data-model="7x3_Angled_Beam.glb">7x3_Angled_Beam</button>
      <button class="part-btn" data-model="7x3x3_Angled_Beam_With_Axle_Hole.glb">7x3x3_Angled_Beam_With_Axle_Hole</button>
      <button class="part-btn" data-model="7x5_Block.glb">7x5_Block</button>
      <button class="part-btn" data-model="10x5_Block.glb">10x5_Block</button>
      <button class="part-btn" data-model="11x5_H_block.glb">11x5_H_block</button>
      <button class="part-btn" data-model="5x11_Technic_Plate.glb">5x11_Technic_Plate</button>
    </div>
     
    <button id="saveBtn" style="position:absolute; top:10px; right:10px; z-index:10; padding:8px 12px; border:none; border-radius:6px; background:#2d89ef; color:white; font-weight:bold; cursor:pointer;">Save JSON</button>
    
    <div id="hint">
      Click object to grab from exact point • Hold <code>Shift</code> for Y-axis (2.6 steps)<br/>
      Mouse wheel for Y movement • <code>R</code> to rotate • <code>Ctrl+D</code> to duplicate<br/>
      Multi-select: <code>Shift+Click</code> • <code>Ctrl+Z</code> to undo
    </div>

    <script type="module">
      // Three.js setup
      const canvas = document.getElementById("app");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(8, 6, 12);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 1, 0);

      // Lighting
      scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5, 10, 6);
      dir.castShadow = true;
      dir.shadow.mapSize.width = 2048;
      dir.shadow.mapSize.height = 2048;
      scene.add(dir);

      // Grid Constants
      const GRID_SIZE = 0.05;
      const GRID_SIZEy = 1.3;

      // Ground
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x232323, transparent: true, opacity: 0.7 });
      const ground = new THREE.Mesh(new THREE.BoxGeometry(40, 0.1, 40), groundMat);
      ground.position.y = -0.05;
      ground.receiveShadow = true;
      scene.add(ground);

      // Gizmo setup
      const gizmoContainer = document.getElementById('gizmo-container');
      const gizmoRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      gizmoRenderer.setSize(80, 80);
      gizmoRenderer.setClearColor(0x000000, 0);
      gizmoContainer.appendChild(gizmoRenderer.domElement);

      const gizmoScene = new THREE.Scene();
      const gizmoCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 10);
      gizmoCamera.position.set(0, 0, 5);

      const gizmoCube = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 1.2, 1.2),
        [
          new THREE.MeshBasicMaterial({ color: 0xff4444 }), // +X Red
          new THREE.MeshBasicMaterial({ color: 0xaa2222 }), // -X Dark Red
          new THREE.MeshBasicMaterial({ color: 0x44ff44 }), // +Y Green
          new THREE.MeshBasicMaterial({ color: 0x22aa22 }), // -Y Dark Green
          new THREE.MeshBasicMaterial({ color: 0x4444ff }), // +Z Blue
          new THREE.MeshBasicMaterial({ color: 0x2222aa })  // -Z Dark Blue
        ]
      );
      gizmoScene.add(gizmoCube);

      gizmoRenderer.domElement.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        const rect = gizmoRenderer.domElement.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), gizmoCamera);
        const intersects = raycaster.intersectObject(gizmoCube);
        
        if (intersects.length > 0) {
          const faceIndex = Math.floor(intersects[0].faceIndex / 2);
          const positions = [
            [15, 2, 0], [-15, 2, 0], [0, 15, 0], [0, -5, 0], [0, 2, 15], [0, 2, -15]
          ];
          
          if (positions[faceIndex]) {
            camera.position.set(...positions[faceIndex]);
            camera.lookAt(controls.target);
          }
        }
      });

      // Core variables
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let currentGrabbed = null;
      let selectedObjects = new Set();
      let isShiftDown = false;
      let isCtrlDown = false;
      const rigidBodies = [];
      let showCollisionDebug = false;
      let collisionEnabled = true;
      let multiSelectionActive = false;

      // Undo system
      const undoStack = [];
      const MAX_UNDO_STEPS = 20;

      function saveUndoState(action, objects) {
        const state = {
          action: action,
          objects: objects.map(obj => ({
            object: obj,
            position: obj.position.clone(),
            rotation: obj.rotation.clone(),
            scale: obj.scale.clone()
          })),
          timestamp: Date.now()
        };
        
        undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STEPS) {
          undoStack.shift();
        }
        
        console.log(`Saved undo state: ${action}, objects: ${objects.length}`);
      }

      function performUndo() {
        if (undoStack.length === 0) {
          console.log('No undo states available');
          return;
        }

        const lastState = undoStack.pop();
        console.log(`Undoing: ${lastState.action}`);

        if (lastState.action === 'delete') {
          // Restore deleted objects
          lastState.objects.forEach(objData => {
            if (!objData.object.parent) { // Only add if not already in scene
              scene.add(objData.object);
              addRigidBody(objData.object);
              objData.object.position.copy(objData.position);
              objData.object.rotation.copy(objData.rotation);
              objData.object.scale.copy(objData.scale);
            }
          });
          updateObjectCount(); // Update count after restoring objects
        } else if (lastState.action === 'move') {
          // Restore previous positions
          lastState.objects.forEach(objData => {
            if (objData.object.parent === scene) { // Make sure object still exists
              objData.object.position.copy(objData.position);
              objData.object.rotation.copy(objData.rotation);
              objData.object.scale.copy(objData.scale);
            }
          });
        } else if (lastState.action === 'spawn') {
          // For spawn actions, remove the spawned objects
          lastState.objects.forEach(objData => {
            if (objData.object.parent === scene) {
              scene.remove(objData.object);
              const rbIndex = rigidBodies.findIndex(rb => rb.object === objData.object);
              if (rbIndex !== -1) {
                rigidBodies[rbIndex].destroy();
                rigidBodies.splice(rbIndex, 1);
              }
            }
          });
          updateObjectCount(); // Update count after removing objects
        }

        selectedObjects.clear();
        currentGrabbed = null;
        multiSelectionActive = false;
        controls.enabled = true;
        updateSelection(); // This will also update the object count
      }

      // FIXED: Movement tracking variables
      let dragStartMousePos = { x: 0, y: 0 }; // Mouse position when drag started
      let dragStartObjectPos = { x: 0, y: 0, z: 0 }; // Object position when drag started
      let clickOffset = { x: 0, y: 0, z: 0 }; // Offset from click point to object center

      class CollisionBox {
        constructor(object) {
          this.object = object;
          this.box = new THREE.Box3();
          this.debugMesh = null;
          this.updateBoundingBox();
        }

        updateBoundingBox() {
          this.object.updateMatrixWorld(true);
          this.box.setFromObject(this.object);
          this.box.expandByScalar(0.1);
        }

        createDebugVisualization() {
          this.removeDebugVisualization();
          if (!showCollisionDebug) return;
          const size = this.box.getSize(new THREE.Vector3());
          const center = this.box.getCenter(new THREE.Vector3());
          const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.8 });
          this.debugMesh = new THREE.Mesh(geometry, material);
          this.debugMesh.position.copy(center);
          this.debugMesh.name = '__collision_debug__';
          scene.add(this.debugMesh);
        }

        removeDebugVisualization() {
          if (this.debugMesh) {
            scene.remove(this.debugMesh);
            this.debugMesh.geometry?.dispose();
            this.debugMesh.material?.dispose();
            this.debugMesh = null;
          }
        }

        intersectsWith(other) {
          return this.box.intersectsBox(other.box);
        }

        destroy() {
          this.removeDebugVisualization();
        }
      }

      function addRigidBody(object) {
        const rb = new CollisionBox(object);
        rigidBodies.push(rb);
        if (showCollisionDebug) rb.createDebugVisualization();
        return rb;
      }

      function snapToGrid(value) {
        return Math.round(value / GRID_SIZE) * GRID_SIZE;
      }

      function snapToGridY(value) {
        return Math.round(value / GRID_SIZEy) * GRID_SIZEy;
      }

      function highlightObject(obj, color = 0x3399ff) {
        if (!obj) return;
        obj.traverse((o) => {
          if (o.isMesh) {
            if (!o.material.userData.originalEmissive) {
              o.material.userData.originalEmissive = o.material.emissive?.clone() || new THREE.Color(0x000000);
            }
            if (o.material.emissive) {
              o.material.emissive.setHex(color);
            }
          }
        });
      }

      function unhighlightObject(obj) {
        if (!obj) return;
        obj.traverse((o) => {
          if (o.isMesh && o.material?.userData?.originalEmissive) {
            if (o.material.emissive) {
              o.material.emissive.copy(o.material.userData.originalEmissive);
            }
          }
        });
      }

      function updateSelection() {
        // Clear all highlights first
        scene.children.forEach(obj => {
          if (obj !== ground && obj.isGroup) {
            unhighlightObject(obj);
          }
        });

        // Highlight selected objects
        selectedObjects.forEach(obj => {
          // Check if object still exists in scene before highlighting
          if (obj.parent === scene) {
            highlightObject(obj, 0xff6600);
          } else {
            // Remove from selection if object no longer in scene
            selectedObjects.delete(obj);
          }
        });

        // Highlight grabbed object
        if (currentGrabbed && currentGrabbed.parent === scene) {
          highlightObject(currentGrabbed, 0x3399ff);
        } else if (currentGrabbed && currentGrabbed.parent !== scene) {
          // Clear grabbed object if it no longer exists
          currentGrabbed = null;
        }

        // Update UI
        const selectedCountElement = document.getElementById('selected-count');
        if (selectedCountElement) {
          selectedCountElement.textContent = selectedObjects.size;
        }
        
        console.log(`Selection updated: ${selectedObjects.size} objects selected`);
      }

      function updateObjectCount() {
        const objectCount = scene.children.filter(obj => 
          obj !== ground && 
          obj.isGroup && 
          !obj.name.includes('debug') &&
          !obj.name.includes('__collision_debug__')
        ).length;
        
        const objectCountElement = document.getElementById('object-count');
        if (objectCountElement) {
          objectCountElement.textContent = objectCount;
        }
        
        console.log(`Total objects in scene: ${objectCount}`);
      }

      function duplicateObject(originalObject) {
        // Create a completely new group instead of cloning
        const duplicatedObject = new THREE.Group();
        
        // Copy all children from original object
        originalObject.children.forEach(child => {
          if (child.isMesh) {
            // Clone geometry and material to make them independent
            const newGeometry = child.geometry.clone();
            const newMaterial = child.material.clone();
            
            // Ensure material has emissive property for highlighting
            if (!newMaterial.emissive) {
              newMaterial.emissive = new THREE.Color(0x000000);
            }
            
            const newMesh = new THREE.Mesh(newGeometry, newMaterial);
            newMesh.name = child.name + "_duplicated_" + Date.now(); // Unique name
            newMesh.castShadow = child.castShadow;
            newMesh.receiveShadow = child.receiveShadow;
            
            // Copy transform
            newMesh.position.copy(child.position);
            newMesh.rotation.copy(child.rotation);
            newMesh.scale.copy(child.scale);
            
            duplicatedObject.add(newMesh);
          }
        });

        // Give the duplicated object a unique name
        duplicatedObject.name = (originalObject.name || "object") + "_dup_" + Date.now();
        
        // Clear userData to make it independent
        duplicatedObject.userData = {};
        
        // Copy transform from original
        duplicatedObject.position.copy(originalObject.position);
        duplicatedObject.rotation.copy(originalObject.rotation);
        duplicatedObject.scale.copy(originalObject.scale);

        // Add to scene
        scene.add(duplicatedObject);
        addRigidBody(duplicatedObject);
        
        // Resolve collisions to prevent overlapping
        resolveCollisions(duplicatedObject);
        
        console.log(`Created new duplicate object: ${duplicatedObject.name} at: ${duplicatedObject.position.x}, ${duplicatedObject.position.y}, ${duplicatedObject.position.z}`);
        return duplicatedObject;
      }

      function duplicateSelectedObjects() {
        const objectsToDuplicate = currentGrabbed ? [currentGrabbed] : Array.from(selectedObjects);
        
        if (objectsToDuplicate.length === 0) {
          console.log('No objects to duplicate');
          return;
        }

        // Save undo state before duplicating
        const originalObjects = objectsToDuplicate.slice();
        
        const duplicatedObjects = [];
        
        objectsToDuplicate.forEach(obj => {
          const duplicated = duplicateObject(obj);
          duplicatedObjects.push(duplicated);
        });
        
        // Save undo state for the duplication
        saveUndoState('spawn', duplicatedObjects);
        
        // Update object count immediately after duplication
        updateObjectCount();
        
        // FIXED: Completely clear all selections and reset state
        selectedObjects.clear();
        currentGrabbed = null;
        multiSelectionActive = false;
        controls.enabled = true;
        
        // Don't auto-select duplicated objects - let user select them manually
        updateSelection(); // This will clear all highlights
        
        // Force another object count update to ensure UI is correct
        setTimeout(() => {
          updateObjectCount();
        }, 100);
        
        console.log(`Successfully duplicated ${duplicatedObjects.length} objects. All selections cleared.`);
      }

      function resolveCollisions(targetObject) {
        if (!collisionEnabled) return;
        const targetBody = rigidBodies.find(b => b.object === targetObject);
        if (!targetBody) return;

        targetBody.updateBoundingBox();

        const minY = targetBody.box.min.y;
        if (minY < 0) {
          targetObject.position.y += Math.abs(minY);
          targetBody.updateBoundingBox();
        }

        for (let otherBody of rigidBodies) {
          if (otherBody.object === targetObject) continue;
          if (targetBody.intersectsWith(otherBody)) {
            const targetCenter = targetBody.box.getCenter(new THREE.Vector3());
            const otherCenter = otherBody.box.getCenter(new THREE.Vector3());
            const separation = targetCenter.clone().sub(otherCenter);
            if (separation.length() < 0.1) separation.set(1, 0, 0);
            separation.normalize();

            const pushDistance = GRID_SIZE * 2;
            const pushVector = separation.multiplyScalar(pushDistance);
            targetObject.position.add(pushVector);
            targetObject.position.x = snapToGrid(targetObject.position.x);
            targetObject.position.z = snapToGrid(targetObject.position.z);
            targetBody.updateBoundingBox();
            break;
          }
        }
      }

      // FIXED: Mouse movement handler
      window.addEventListener("mousemove", (e) => {
        const objectsToMove = currentGrabbed ? [currentGrabbed] : 
                             (multiSelectionActive ? Array.from(selectedObjects) : []);
        
        if (objectsToMove.length === 0) return;

        const currentMouseX = (e.clientX / window.innerWidth) * 2 - 1;
        const currentMouseY = -(e.clientY / window.innerHeight) * 2 + 1;

        if (isShiftDown) {
          // FIXED: Y-axis movement with exact 2.6 steps for both single and multi-select
          const mouseDeltaY = currentMouseY - dragStartMousePos.y;
          const steps = Math.round(mouseDeltaY * 4); // Sensitivity - adjust if needed
          
          if (multiSelectionActive) {
            // Multi-select Y movement - move all objects by the same amount
            const deltaY = steps * GRID_SIZEy;
            objectsToMove.forEach(obj => {
              const newY = Math.max(0, obj.userData.originalPos.y + deltaY);
              obj.position.y = newY;
              resolveCollisions(obj);
            });
            console.log(`Multi Y Movement - Steps: ${steps}, Delta Y: ${deltaY}, Objects: ${objectsToMove.length}`);
          } else {
            // Single object Y movement
            const newY = Math.max(0, dragStartObjectPos.y + (steps * GRID_SIZEy));
            objectsToMove.forEach(obj => {
              obj.position.y = newY;
              resolveCollisions(obj);
            });
            console.log(`Single Y Movement - Steps: ${steps}, New Y: ${newY}`);
          }
        } else {
          // FIXED: XZ movement with click offset for multi-selection
          raycaster.setFromCamera(new THREE.Vector2(currentMouseX, currentMouseY), camera);
          const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -dragStartObjectPos.y);
          const intersection = new THREE.Vector3();
          
          if (raycaster.ray.intersectPlane(plane, intersection)) {
            const deltaX = intersection.x - clickOffset.x - dragStartObjectPos.x;
            const deltaZ = intersection.z - clickOffset.z - dragStartObjectPos.z;
            
            objectsToMove.forEach(obj => {
              if (obj === currentGrabbed) {
                obj.position.x = intersection.x - clickOffset.x;
                obj.position.z = intersection.z - clickOffset.z;
              } else {
                // For multi-selected objects, move relative to the main object
                obj.position.x = obj.userData.originalPos.x + deltaX;
                obj.position.z = obj.userData.originalPos.z + deltaZ;
              }
              resolveCollisions(obj);
            });
          }
        }
      });

      // Mouse wheel for Y movement
      window.addEventListener("wheel", (e) => {
        const objectsToMove = currentGrabbed ? [currentGrabbed] : 
                             (multiSelectionActive ? Array.from(selectedObjects) : []);
        
        if (objectsToMove.length === 0) return;
        
        e.preventDefault();
        const direction = e.deltaY > 0 ? -1 : 1;
        
        objectsToMove.forEach(obj => {
          const newY = Math.max(0, obj.position.y + (direction * GRID_SIZEy));
          obj.position.y = newY;
          resolveCollisions(obj);
        });
        
        console.log(`Wheel Y Movement - Objects moved: ${objectsToMove.length}`); // Debug log
      });

      // FIXED: Click handler
      window.addEventListener("click", (e) => {
        if (e.target.closest('#sidebar') || e.target.closest('#multi-controls') || e.target.closest('#gizmo-container')) {
          return;
        }

        if (currentGrabbed || multiSelectionActive) {
          // Save undo state before dropping
          const objectsToSave = currentGrabbed ? [currentGrabbed] : Array.from(selectedObjects);
          saveUndoState('move', objectsToSave);
          
          // Drop objects and snap to grid
          const objectsToSnap = currentGrabbed ? [currentGrabbed] : Array.from(selectedObjects);
          objectsToSnap.forEach(obj => {
            obj.position.x = snapToGrid(obj.position.x);
            obj.position.y = snapToGridY(obj.position.y);
            obj.position.z = snapToGrid(obj.position.z);
            // Clear original position data
            if (obj.userData.originalPos) {
              delete obj.userData.originalPos;
            }
          });
          
          currentGrabbed = null;
          multiSelectionActive = false;
          controls.enabled = true;
          updateSelection();
        } else {
          // Try to grab object
          const x = (e.clientX / window.innerWidth) * 2 - 1;
          const y = -(e.clientY / window.innerHeight) * 2 + 1;
          mouse.set(x, y);
          raycaster.setFromCamera(mouse, camera);

          const hits = raycaster.intersectObjects(scene.children, true);
          const validHits = hits.filter(hit => 
            hit.object !== ground && !hit.object.name.includes('debug')
          );
          
          if (validHits.length > 0) {
            let target = validHits[0].object;
            while (target.parent && target.parent !== scene) {
              target = target.parent;
            }

            if (e.shiftKey) {
              // Multi-selection mode
              if (selectedObjects.has(target)) {
                selectedObjects.delete(target);
              } else {
                selectedObjects.add(target);
              }
              updateSelection();
            } else {
              // Check if clicking on selected object to start multi-move
              if (selectedObjects.has(target) && selectedObjects.size > 1) {
                // Start multi-selection movement
                multiSelectionActive = true;
                controls.enabled = false;
                
                // Store original positions for all selected objects
                selectedObjects.forEach(obj => {
                  obj.userData.originalPos = {
                    x: obj.position.x,
                    y: obj.position.y,
                    z: obj.position.z
                  };
                });
                
                // FIXED: Calculate click offset from exact hit point
                const hitPoint = validHits[0].point;
                clickOffset.x = hitPoint.x - target.position.x;
                clickOffset.y = 0;
                clickOffset.z = hitPoint.z - target.position.z;
                
                // Store initial positions
                dragStartMousePos.x = x;
                dragStartMousePos.y = y;
                dragStartObjectPos.x = target.position.x;
                dragStartObjectPos.y = target.position.y;
                dragStartObjectPos.z = target.position.z;
                
                console.log(`Started multi-move with ${selectedObjects.size} objects`);
              } else {
                // Single object grab
                // FIXED: Calculate click offset from exact hit point
                const hitPoint = validHits[0].point;
                clickOffset.x = hitPoint.x - target.position.x;
                clickOffset.y = 0; // Don't offset Y
                clickOffset.z = hitPoint.z - target.position.z;
                
                // Store initial positions
                dragStartMousePos.x = x;
                dragStartMousePos.y = y;
                dragStartObjectPos.x = target.position.x;
                dragStartObjectPos.y = target.position.y;
                dragStartObjectPos.z = target.position.z;

                selectedObjects.clear();
                currentGrabbed = target;
                controls.enabled = false;
                
                console.log(`Grabbed object at: ${target.position.x}, ${target.position.y}, ${target.position.z}`);
                console.log(`Click offset: ${clickOffset.x}, ${clickOffset.z}`);
              }
              
              updateSelection();
            }
          } else if (!e.shiftKey) {
            // Click on empty space - clear all selections
            selectedObjects.clear();
            currentGrabbed = null;
            multiSelectionActive = false;
            controls.enabled = true;
            updateSelection();
            console.log('Cleared all selections');
          }
        }
      });

      // Keyboard controls
      window.addEventListener("keydown", (e) => {
        if (e.key === "Shift") isShiftDown = true;
        if (e.key === "Control" || e.key === "Meta") isCtrlDown = true;

        // Undo with Ctrl+Z
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          performUndo();
          return;
        }

        // Duplicate with Ctrl+D
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
          e.preventDefault();
          duplicateSelectedObjects();
          return;
        }

        if (e.key.toLowerCase() === "r") {
          const objectsToRotate = currentGrabbed ? [currentGrabbed] : Array.from(selectedObjects);
          
          if (objectsToRotate.length > 0) {
            saveUndoState('move', objectsToRotate);
            
            objectsToRotate.forEach(obj => {
              if (e.ctrlKey || e.metaKey) {
                obj.rotation.y += Math.PI / 2;
              } else if (e.shiftKey) {
                obj.rotation.z += Math.PI / 2;
              } else {
                obj.rotation.x += Math.PI / 2;
              }
              resolveCollisions(obj);
            });
          }
        }

        if (e.key === "Delete" || e.key === "Backspace") {
          const objectsToDelete = currentGrabbed ? [currentGrabbed] : Array.from(selectedObjects);
          
          if (objectsToDelete.length > 0) {
            saveUndoState('delete', objectsToDelete);
            
            objectsToDelete.forEach(obj => {
              scene.remove(obj);
              const rbIndex = rigidBodies.findIndex(rb => rb.object === obj);
              if (rbIndex !== -1) {
                rigidBodies[rbIndex].destroy();
                rigidBodies.splice(rbIndex, 1);
              }
              selectedObjects.delete(obj);
            });
            
            currentGrabbed = null;
            multiSelectionActive = false;
            controls.enabled = true;
            updateSelection();
            updateObjectCount(); // Update count after deletion
          }
        }

        if (e.key === "Escape") {
          currentGrabbed = null;
          multiSelectionActive = false;
          selectedObjects.clear();
          controls.enabled = true;
          updateSelection();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "Shift") isShiftDown = false;
        if (e.key === "Control" || e.key === "Meta") isCtrlDown = false;
      });

      // Debug controls
      const toggleDebugBtn = document.getElementById('toggle-debug');
      if (toggleDebugBtn) {
        toggleDebugBtn.addEventListener('click', () => {
          showCollisionDebug = !showCollisionDebug;
          toggleDebugBtn.textContent = showCollisionDebug ? 'Hide Collision Box' : 'Show Collision Box';
          rigidBodies.forEach(rb => {
            if (showCollisionDebug) {
              rb.createDebugVisualization();
            } else {
              rb.removeDebugVisualization();
            }
          });
        });
      }

      const disableCollisionBtn = document.getElementById('disable-collision');
      if (disableCollisionBtn) {
        disableCollisionBtn.addEventListener('click', () => {
          collisionEnabled = !collisionEnabled;
          disableCollisionBtn.textContent = collisionEnabled ? 'Disable Collision' : 'Enable Collision';
        });
      }

      const clearSelectionBtn = document.getElementById('clear-selection');
      if (clearSelectionBtn) {
        clearSelectionBtn.addEventListener('click', () => {
          selectedObjects.clear();
          currentGrabbed = null;
          multiSelectionActive = false;
          controls.enabled = true;
          updateSelection();
        });
      }
      
      const deleteSelectedBtn = document.getElementById('delete-selected');
      if (deleteSelectedBtn) {
        deleteSelectedBtn.addEventListener('click', () => {
          const objectsToDelete = Array.from(selectedObjects);
          if (objectsToDelete.length > 0) {
            saveUndoState('delete', objectsToDelete);
            
            objectsToDelete.forEach(obj => {
              scene.remove(obj);
              const rbIndex = rigidBodies.findIndex(rb => rb.object === obj);
              if (rbIndex !== -1) {
                rigidBodies[rbIndex].destroy();
                rigidBodies.splice(rbIndex, 1);
              }
            });
          }
          selectedObjects.clear();
          currentGrabbed = null;
          multiSelectionActive = false;
          controls.enabled = true;
          updateSelection();
          updateObjectCount(); // Update count after deletion
        });
      }

      const undoBtn = document.getElementById('undo-btn');
      if (undoBtn) {
        undoBtn.addEventListener('click', () => {
          performUndo();
        });
      }

      const duplicateBtn = document.getElementById('duplicate-selected');
      if (duplicateBtn) {
        duplicateBtn.addEventListener('click', () => {
          duplicateSelectedObjects();
        });
      }

      // Model spawning
      const gltfLoader = new THREE.GLTFLoader();
      const partButtons = document.querySelectorAll(".part-btn");
      
      partButtons.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (currentGrabbed) return;

          const file = btn.dataset.model;
          gltfLoader.load(`models/${file}`, (gltf) => {
            const model = gltf.scene || gltf.scenes?.[0];
            if (!model) return;

            model.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
                if (o.material) {
                  o.material.side = THREE.FrontSide;
                  if (!o.material.emissive) {
                    o.material.emissive = new THREE.Color(0x000000);
                  }
                }
              }
            });

            // Save undo state before spawning (save empty state since object doesn't exist yet)
            const tempUndoState = {
              action: 'spawn',
              objects: [], // Will be filled after object is created
              timestamp: Date.now()
            };
            
            model.position.set(0, GRID_SIZEy * 2, 0); // Spawn at Y = 5.2
            scene.add(model);
            addRigidBody(model);
            
            // Now save the actual undo state with the created object
            tempUndoState.objects = [{
              object: model,
              position: new THREE.Vector3(0, 0, 0), // Original spawn position would be (0,0,0) conceptually
              rotation: new THREE.Euler(0, 0, 0),
              scale: new THREE.Vector3(1, 1, 1)
            }];
            undoStack.push(tempUndoState);
            if (undoStack.length > MAX_UNDO_STEPS) {
              undoStack.shift();
            }
            
            // Auto-grab new object
            selectedObjects.clear();
            currentGrabbed = model;
            controls.enabled = false;
            
            // Initialize drag variables
            dragStartMousePos.x = 0;
            dragStartMousePos.y = 0;
            dragStartObjectPos = { x: model.position.x, y: model.position.y, z: model.position.z };
            clickOffset = { x: 0, y: 0, z: 0 };
            
            updateSelection();
            resolveCollisions(model);
            updateObjectCount(); // Update count after adding new object
          }, undefined, (error) => {
            console.warn(`Could not load model: ${file}`, error);
          });
        });
      });

      // Export functionality
      function getSceneObjects() {
        const objects = [];
        scene.children.forEach((obj) => {
          if (obj !== ground && obj.isGroup && !obj.name.includes('debug')) {
            objects.push({
              name: obj.name || obj.children[0]?.name || "Unnamed",
              position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
              rotation: { x: obj.rotation.x, y: obj.rotation.y, z: obj.rotation.z },
              scale: { x: obj.scale.x, y: obj.scale.y, z: obj.scale.z },
              model: obj.children[0]?.name || "Unknown"
            });
          }
        });
        return objects;
      }

      function exportToJSON() {
        const objects = getSceneObjects();
        const jsonData = JSON.stringify(objects, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'lego_scene.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      const saveBtn = document.getElementById('saveBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', exportToJSON);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize object count on page load
      function initializeApp() {
        updateObjectCount(); // Set initial count to 0
        updateSelection(); // Set initial selection to 0
      }

      // Call initialization
      initializeApp();

      function animate() {
        requestAnimationFrame(animate);
        if (controls.enabled) controls.update();
        
        const quaternion = new THREE.Quaternion();
        quaternion.setFromRotationMatrix(camera.matrixWorld);
        gizmoCube.quaternion.copy(quaternion);
        
        if (showCollisionDebug) {
          rigidBodies.forEach(rb => {
            rb.updateBoundingBox();
            if (rb.debugMesh) {
              rb.removeDebugVisualization();
              rb.createDebugVisualization();
            }
          });
        }
        
        renderer.render(scene, camera);
        gizmoRenderer.render(gizmoScene, gizmoCamera);
      }
      
      animate();
    </script>
  </body>
</html>
